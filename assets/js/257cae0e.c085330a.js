"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[2081],{3737:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module3-ai-robot-brain/nav2-path-planning","title":"Nav2 (Path Planning for Bipedal Humanoid Movement)","description":"Introduction","source":"@site/docs/module3-ai-robot-brain/nav2-path-planning.md","sourceDirName":"module3-ai-robot-brain","slug":"/module3-ai-robot-brain/nav2-path-planning","permalink":"/physical-ai-textbook_01/docs/module3-ai-robot-brain/nav2-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/umernasir1/physical-ai-textbook/tree/main/docs/module3-ai-robot-brain/nav2-path-planning.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Nav2 (Path Planning for Bipedal Humanoid Movement)"},"sidebar":"tutorialSidebar","previous":{"title":"Isaac ROS (Hardware-accelerated VSLAM and Navigation)","permalink":"/physical-ai-textbook_01/docs/module3-ai-robot-brain/isaac-ros-vslam-navigation"},"next":{"title":"Module 4: Vision-Language-Action (VLA)","permalink":"/physical-ai-textbook_01/docs/category/module-4-vision-language-action-vla"}}');var t=a(4848),i=a(8453);const r={sidebar_position:4,title:"Nav2 (Path Planning for Bipedal Humanoid Movement)"},s="Nav2 (Path Planning for Bipedal Humanoid Movement)",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Nav2 Architecture",id:"nav2-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Installation",id:"installation",level:3},{value:"Configuring Nav2 for Humanoid Robots",id:"configuring-nav2-for-humanoid-robots",level:2},{value:"Robot Footprint",id:"robot-footprint",level:3},{value:"Controller Parameters",id:"controller-parameters",level:3},{value:"Costmap Configuration",id:"costmap-configuration",level:3},{value:"Global Costmap (Long-range planning)",id:"global-costmap-long-range-planning",level:3},{value:"Local Costmap (Short-range obstacle avoidance)",id:"local-costmap-short-range-obstacle-avoidance",level:3},{value:"Path Planners for Humanoids",id:"path-planners-for-humanoids",level:2},{value:"NavFn vs Smac Planner",id:"navfn-vs-smac-planner",level:3},{value:"Gait Integration: From Path to Footsteps",id:"gait-integration-from-path-to-footsteps",level:2},{value:"Footstep Planner Node",id:"footstep-planner-node",level:3},{value:"Behavior Trees for Complex Navigation",id:"behavior-trees-for-complex-navigation",level:2},{value:"Custom Humanoid Behaviors",id:"custom-humanoid-behaviors",level:3},{value:"Launch File",id:"launch-file",level:2},{value:"Testing and Visualization",id:"testing-and-visualization",level:2},{value:"Handling Stairs and Uneven Terrain",id:"handling-stairs-and-uneven-terrain",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"nav2-path-planning-for-bipedal-humanoid-movement",children:"Nav2 (Path Planning for Bipedal Humanoid Movement)"})}),"\n",(0,t.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Nav2"})," (Navigation2) is the next-generation navigation framework for ROS 2. While originally designed for wheeled robots, Nav2 can be adapted for humanoid robots with careful consideration of bipedal locomotion constraints."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Differences for Humanoids:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Non-holonomic constraints"}),": Cannot move sideways without turning"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Step planning"}),": Discrete foot placements vs continuous wheel motion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Balance considerations"}),": Center of mass must stay within support polygon"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Slower speeds"}),": Typical humanoid walk: 0.5-1.5 m/s vs wheeled robots: 1-3 m/s"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Higher turning costs"}),": Rotating requires coordinated leg movements"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This chapter covers how to configure Nav2 for humanoid robots and integrate gait planning with path planning."}),"\n",(0,t.jsx)(e.h2,{id:"nav2-architecture",children:"Nav2 Architecture"}),"\n",(0,t.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Goal \u2192 Planner Server \u2192 Path \u2192 Controller Server \u2192 Cmd_Vel\n         \u2193                        \u2193\n    Global Costmap          Local Costmap\n         \u2193                        \u2193\n    Static Map +            Sensor Data\n    Inflation               (LiDAR, Camera)\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Nav2 Behavior Tree:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"NavigateToPose\n\u251c\u2500\u2500 ComputePathToPose (global planner)\n\u251c\u2500\u2500 FollowPath (controller)\n\u251c\u2500\u2500 ClearCostmap (recovery)\n\u2514\u2500\u2500 Spin (recovery)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup\nsudo apt install ros-humble-turtlebot3-*  # Useful examples\n"})}),"\n",(0,t.jsx)(e.h2,{id:"configuring-nav2-for-humanoid-robots",children:"Configuring Nav2 for Humanoid Robots"}),"\n",(0,t.jsx)(e.h3,{id:"robot-footprint",children:"Robot Footprint"}),"\n",(0,t.jsx)(e.p,{children:"Unlike circular robots, humanoids have a rectangular footprint that changes during walking."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# config/humanoid_footprint.yaml\nrobot_base_frame: "base_link"\n\n# Conservative footprint (shoulders width x forward reach)\nfootprint: "[[0.25, 0.25], [0.25, -0.25], [-0.25, -0.25], [-0.25, 0.25]]"\n\n# Alternative: circular approximation (radius in meters)\n# robot_radius: 0.35\n'})}),"\n",(0,t.jsx)(e.h3,{id:"controller-parameters",children:"Controller Parameters"}),"\n",(0,t.jsx)(e.p,{children:"Humanoids need slower, smoother commands than wheeled robots."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# config/controller.yaml\ncontroller_server:\n  ros__parameters:\n    controller_frequency: 20.0  # Hz (higher for stability)\n    min_x_velocity_threshold: 0.01  # m/s\n    min_y_velocity_threshold: 0.0   # No lateral movement\n    min_theta_velocity_threshold: 0.01  # rad/s\n\n    # DWB Controller (Dynamic Window Approach - Bipedal)\n    FollowPath:\n      plugin: "dwb_core::DWBLocalPlanner"\n\n      # Velocity limits (conservative for humanoids)\n      min_vel_x: 0.0\n      max_vel_x: 0.8  # Slow walk\n      min_vel_y: 0.0  # No strafing\n      max_vel_y: 0.0\n      max_vel_theta: 0.5  # 30 deg/s turning\n\n      # Acceleration limits (smooth starts/stops)\n      acc_lim_x: 0.3  # m/s\xb2\n      acc_lim_y: 0.0\n      acc_lim_theta: 0.5  # rad/s\xb2\n\n      # Deceleration limits (prevent falling forward)\n      decel_lim_x: -0.5  # Stronger braking\n      decel_lim_theta: -1.0\n\n      # Trajectory generation\n      vx_samples: 10  # Test 10 forward velocities\n      vy_samples: 1   # No lateral motion\n      vtheta_samples: 20  # Test 20 rotational velocities\n\n      # Simulation time (predict N seconds ahead)\n      sim_time: 2.0  # Longer for slow humanoids\n\n      # Critics (cost functions)\n      critics: [\n        "RotateToGoal",\n        "Oscillation",\n        "BaseObstacle",\n        "GoalAlign",\n        "PathAlign",\n        "PathDist",\n        "GoalDist"\n      ]\n\n      # Humanoid-specific tuning\n      BaseObstacle.scale: 0.02  # Obstacle avoidance weight\n      PathAlign.scale: 32.0     # Stay on path (important for stability)\n      PathDist.scale: 32.0      # Progress along path\n      GoalAlign.scale: 24.0     # Final orientation\n      GoalDist.scale: 24.0      # Reach goal\n\n      # Path following tolerance\n      xy_goal_tolerance: 0.1  # 10cm\n      yaw_goal_tolerance: 0.15  # ~9 degrees\n'})}),"\n",(0,t.jsx)(e.h3,{id:"costmap-configuration",children:"Costmap Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# config/costmap_common.yaml\ncostmap_common:\n  ros__parameters:\n    footprint: "[[0.25, 0.25], [0.25, -0.25], [-0.25, -0.25], [-0.25, 0.25]]"\n    robot_radius: 0.35  # Backup if footprint fails\n\n    # Obstacle layer (from sensors)\n    obstacle_layer:\n      plugin: "nav2_costmap_2d::ObstacleLayer"\n      observation_sources: "scan"\n\n      scan:\n        topic: /scan\n        sensor_frame: lidar_link\n        observation_persistence: 0.0  # Seconds to keep old data\n        expected_update_rate: 5.0  # Hz\n        data_type: "LaserScan"\n        min_obstacle_height: 0.0  # Ground level\n        max_obstacle_height: 2.0  # Ceiling height\n        inf_is_valid: false\n        marking: true  # Add obstacles\n        clearing: true  # Remove obstacles when not seen\n        raytrace_range: 10.0  # Clear out to 10m\n        obstacle_range: 8.0   # Detect obstacles to 8m\n\n    # Inflation layer (safety margin)\n    inflation_layer:\n      plugin: "nav2_costmap_2d::InflationLayer"\n      inflation_radius: 0.55  # Robot radius + safety margin\n      cost_scaling_factor: 3.0  # How fast cost increases\n\n    # Static map layer\n    static_layer:\n      plugin: "nav2_costmap_2d::StaticLayer"\n      map_subscribe_transient_local: true\n      enabled: true\n\n    always_send_full_costmap: true\n'})}),"\n",(0,t.jsx)(e.h3,{id:"global-costmap-long-range-planning",children:"Global Costmap (Long-range planning)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# config/global_costmap.yaml\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0  # Hz (slow updates for efficiency)\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n\n      resolution: 0.05  # 5cm grid cells\n      width: 100  # 100 cells = 5m\n      height: 100\n      origin_x: -2.5\n      origin_y: -2.5\n\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n'})}),"\n",(0,t.jsx)(e.h3,{id:"local-costmap-short-range-obstacle-avoidance",children:"Local Costmap (Short-range obstacle avoidance)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# config/local_costmap.yaml\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0  # Hz (faster for dynamic obstacles)\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n\n      resolution: 0.025  # 2.5cm grid (finer than global)\n      width: 5  # 5 cells = 12.5cm\n      height: 5\n      origin_x: -1.25  # Center robot\n      origin_y: -1.25\n\n      rolling_window: true  # Move with robot\n      plugins: ["obstacle_layer", "inflation_layer"]\n'})}),"\n",(0,t.jsx)(e.h2,{id:"path-planners-for-humanoids",children:"Path Planners for Humanoids"}),"\n",(0,t.jsx)(e.h3,{id:"navfn-vs-smac-planner",children:"NavFn vs Smac Planner"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Planner"}),(0,t.jsx)(e.th,{children:"Algorithm"}),(0,t.jsx)(e.th,{children:"Best For"}),(0,t.jsx)(e.th,{children:"Humanoid Suitability"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"NavFn"})}),(0,t.jsx)(e.td,{children:"Dijkstra / A*"}),(0,t.jsx)(e.td,{children:"Simple environments"}),(0,t.jsx)(e.td,{children:"\u2713 Good (fast, smooth)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"SmacPlanner2D"})}),(0,t.jsx)(e.td,{children:"Hybrid A*"}),(0,t.jsx)(e.td,{children:"Complex environments"}),(0,t.jsx)(e.td,{children:"\u2713\u2713 Better (considers orientation)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"SmacPlannerHybrid"})}),(0,t.jsx)(e.td,{children:"State Lattice"}),(0,t.jsx)(e.td,{children:"Parking-like"}),(0,t.jsx)(e.td,{children:"\u2717 Overkill (car-like motion)"})]})]})]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Recommended: SmacPlanner2D"})," for humanoids."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# config/planner_server.yaml\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 1.0  # Hz\n    planner_plugins: ["GridBased"]\n\n    GridBased:\n      plugin: "nav2_smac_planner/SmacPlanner2D"\n\n      # Grid search parameters\n      tolerance: 0.25  # Goal tolerance (meters)\n      downsample_costmap: false  # Use full resolution\n      downsampling_factor: 1\n\n      # A* tuning\n      allow_unknown: true  # Plan through unexplored areas\n      max_iterations: 1000000\n      max_planning_time: 5.0  # seconds\n\n      # Smoothing (critical for humanoids)\n      smoother:\n        max_iterations: 1000\n        w_smooth: 0.3  # Smoothness weight\n        w_data: 0.2    # Fidelity to original path\n        tolerance: 1e-10\n'})}),"\n",(0,t.jsx)(e.h2,{id:"gait-integration-from-path-to-footsteps",children:"Gait Integration: From Path to Footsteps"}),"\n",(0,t.jsxs)(e.p,{children:["Nav2 produces smooth paths, but humanoids walk in discrete steps. We need a ",(0,t.jsx)(e.strong,{children:"footstep planner"}),"."]}),"\n",(0,t.jsx)(e.h3,{id:"footstep-planner-node",children:"Footstep Planner Node"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Path\nfrom geometry_msgs.msg import PoseStamped\nimport numpy as np\n\nclass FootstepPlanner(Node):\n    def __init__(self):\n        super().__init__('footstep_planner')\n\n        # Subscribe to Nav2 path\n        self.path_sub = self.create_subscription(\n            Path,\n            '/plan',\n            self.path_callback,\n            10\n        )\n\n        # Publish footstep sequence\n        self.footstep_pub = self.create_publisher(\n            Path,  # Each pose is a foot placement\n            '/footsteps',\n            10\n        )\n\n        # Humanoid parameters\n        self.step_length = 0.3  # meters\n        self.step_width = 0.2   # lateral foot separation\n        self.step_height = 0.05  # foot clearance\n\n    def path_callback(self, path_msg):\n        \"\"\"Convert continuous path to discrete footsteps\"\"\"\n\n        if len(path_msg.poses) < 2:\n            return\n\n        footsteps = []\n        current_foot = 'left'  # Start with left foot\n\n        # Sample path at step_length intervals\n        for i in range(0, len(path_msg.poses), 1):\n            pose = path_msg.poses[i].pose\n\n            # Alternate feet\n            if current_foot == 'left':\n                lateral_offset = self.step_width / 2\n                current_foot = 'right'\n            else:\n                lateral_offset = -self.step_width / 2\n                current_foot = 'left'\n\n            # Create footstep pose\n            footstep = PoseStamped()\n            footstep.header = path_msg.header\n            footstep.pose.position.x = pose.position.x\n            footstep.pose.position.y = pose.position.y + lateral_offset\n            footstep.pose.position.z = self.step_height\n            footstep.pose.orientation = pose.orientation\n\n            footsteps.append(footstep)\n\n        # Publish footstep plan\n        footstep_path = Path()\n        footstep_path.header = path_msg.header\n        footstep_path.poses = footsteps\n\n        self.footstep_pub.publish(footstep_path)\n\n        self.get_logger().info(f'Generated {len(footsteps)} footsteps')\n\ndef main():\n    rclpy.init()\n    node = FootstepPlanner()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"behavior-trees-for-complex-navigation",children:"Behavior Trees for Complex Navigation"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 uses behavior trees to handle failures gracefully."}),"\n",(0,t.jsx)(e.h3,{id:"custom-humanoid-behaviors",children:"Custom Humanoid Behaviors"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom nav2_msgs.action import NavigateToPose\nfrom rclpy.action import ActionClient\n\nclass HumanoidNavigator(Node):\n    def __init__(self):\n        super().__init__('humanoid_navigator')\n\n        # Action client for Nav2\n        self.nav_client = ActionClient(\n            self,\n            NavigateToPose,\n            '/navigate_to_pose'\n        )\n\n    def navigate_to_goal(self, x, y, theta):\n        \"\"\"Send navigation goal with humanoid-specific behaviors\"\"\"\n\n        goal_msg = NavigateToPose.Goal()\n\n        # Set target pose\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n        goal_msg.pose.pose.position.x = x\n        goal_msg.pose.pose.position.y = y\n        goal_msg.pose.pose.position.z = 0.0\n\n        # Orientation (convert theta to quaternion)\n        goal_msg.pose.pose.orientation.z = np.sin(theta / 2)\n        goal_msg.pose.pose.orientation.w = np.cos(theta / 2)\n\n        # Behavior tree configuration\n        goal_msg.behavior_tree = ''  # Use default, or custom XML\n\n        # Wait for action server\n        self.nav_client.wait_for_server()\n\n        # Send goal\n        send_goal_future = self.nav_client.send_goal_async(goal_msg)\n        rclpy.spin_until_future_complete(self, send_goal_future)\n\n        goal_handle = send_goal_future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().error('Goal rejected')\n            return False\n\n        # Wait for result\n        result_future = goal_handle.get_result_async()\n        rclpy.spin_until_future_complete(self, result_future)\n\n        result = result_future.result().result\n\n        if result:\n            self.get_logger().info('Goal reached!')\n            return True\n        else:\n            self.get_logger().warn('Navigation failed')\n            return False\n\ndef main():\n    rclpy.init()\n    navigator = HumanoidNavigator()\n\n    # Example: navigate to (2.0, 1.5) facing 45 degrees\n    navigator.navigate_to_goal(2.0, 1.5, np.pi/4)\n\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"launch-file",children:"Launch File"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# launch/humanoid_nav2.launch.py\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    pkg_dir = get_package_share_directory('my_humanoid_robot')\n\n    return LaunchDescription([\n        # Nav2 Lifecycle Manager\n        Node(\n            package='nav2_lifecycle_manager',\n            executable='lifecycle_manager',\n            name='lifecycle_manager_navigation',\n            parameters=[{\n                'autostart': True,\n                'node_names': [\n                    'controller_server',\n                    'planner_server',\n                    'behavior_server',\n                    'bt_navigator'\n                ]\n            }]\n        ),\n\n        # Controller Server\n        Node(\n            package='nav2_controller',\n            executable='controller_server',\n            parameters=[os.path.join(pkg_dir, 'config', 'controller.yaml')],\n            remappings=[('/cmd_vel', '/humanoid/cmd_vel')]\n        ),\n\n        # Planner Server\n        Node(\n            package='nav2_planner',\n            executable='planner_server',\n            parameters=[os.path.join(pkg_dir, 'config', 'planner_server.yaml')]\n        ),\n\n        # Behavior Server\n        Node(\n            package='nav2_behaviors',\n            executable='behavior_server',\n            parameters=[os.path.join(pkg_dir, 'config', 'behavior.yaml')]\n        ),\n\n        # BT Navigator\n        Node(\n            package='nav2_bt_navigator',\n            executable='bt_navigator',\n            parameters=[os.path.join(pkg_dir, 'config', 'bt_navigator.yaml')]\n        ),\n\n        # Footstep Planner\n        Node(\n            package='my_humanoid_robot',\n            executable='footstep_planner',\n        ),\n    ])\n"})}),"\n",(0,t.jsx)(e.h2,{id:"testing-and-visualization",children:"Testing and Visualization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Launch Nav2\nros2 launch my_humanoid_robot humanoid_nav2.launch.py\n\n# Open RViz2\nros2 run rviz2 rviz2 -d $(ros2 pkg prefix nav2_bringup)/share/nav2_bringup/rviz/nav2_default_view.rviz\n\n# Send a test goal via command line\nros2 action send_goal /navigate_to_pose nav2_msgs/action/NavigateToPose \"{pose: {header: {frame_id: 'map'}, pose: {position: {x: 2.0, y: 1.0}, orientation: {w: 1.0}}}}\"\n\n# Monitor performance\nros2 topic hz /plan  # Path generation rate\nros2 topic echo /cmd_vel  # Velocity commands\n"})}),"\n",(0,t.jsx)(e.h2,{id:"handling-stairs-and-uneven-terrain",children:"Handling Stairs and Uneven Terrain"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 assumes flat ground. For stairs, we need custom planning."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"class StairClimbingBehavior(Node):\n    def __init__(self):\n        super().__init__('stair_climbing_behavior')\n\n        # Detect stairs in costmap\n        self.costmap_sub = self.create_subscription(\n            OccupancyGrid,\n            '/local_costmap/costmap',\n            self.detect_stairs,\n            10\n        )\n\n    def detect_stairs(self, costmap_msg):\n        \"\"\"Identify stair-like obstacles\"\"\"\n\n        # Look for vertical edges in costmap\n        # If edge height > 0.1m and < 0.2m \u2192 stairs\n        # If edge height > 0.2m \u2192 wall (avoid)\n\n        # Simplified detection:\n        # Count cells with high cost in vertical line\n\n        pass  # Implement stair detection\n\n    def plan_stair_climb(self, stair_location):\n        \"\"\"Generate footsteps for stair climbing\"\"\"\n\n        # 1. Align robot perpendicular to stairs\n        # 2. Lift leading foot to step height\n        # 3. Shift weight, bring trailing foot\n        # 4. Repeat for N steps\n\n        footsteps = []\n        step_height = 0.18  # Standard stair: 18cm\n        step_depth = 0.28   # Tread: 28cm\n\n        for step_idx in range(num_stairs):\n            # Leading foot\n            footsteps.append({\n                'foot': 'left' if step_idx % 2 == 0 else 'right',\n                'x': stair_location.x + step_idx * step_depth,\n                'y': stair_location.y,\n                'z': step_idx * step_height\n            })\n\n        return footsteps\n"})}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 provides a robust navigation framework that can be adapted for humanoid robots:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Adaptations:"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Slower velocities"}),": 0.5-1.5 m/s walking speed"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"No lateral motion"}),": Set ",(0,t.jsx)(e.code,{children:"max_vel_y = 0"})]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Longer sim time"}),": 2-3 seconds for trajectory prediction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Higher path alignment"}),": Humanoids cannot deviate easily"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Footstep planning"}),": Convert smooth paths to discrete steps"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Best Practices:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Use SmacPlanner2D for better orientation handling"}),"\n",(0,t.jsx)(e.li,{children:"Inflate obstacles generously (humanoids are less agile)"}),"\n",(0,t.jsx)(e.li,{children:"Add recovery behaviors for falls"}),"\n",(0,t.jsx)(e.li,{children:"Integrate gait controller for stable walking"}),"\n",(0,t.jsx)(e.li,{children:"Save maps for faster startup"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Performance Tips:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Local costmap: 5-10 Hz update"}),"\n",(0,t.jsx)(e.li,{children:"Global costmap: 1 Hz update"}),"\n",(0,t.jsx)(e.li,{children:"Controller: 20 Hz (balance-critical)"}),"\n",(0,t.jsx)(e.li,{children:"Path planning: On-demand (expensive)"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"With proper tuning, Nav2 enables humanoid robots to navigate autonomously while respecting the constraints of bipedal locomotion."})]})}function p(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>r,x:()=>s});var o=a(6540);const t={},i=o.createContext(t);function r(n){const e=o.useContext(i);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);